---
layout: post
title:  "Spring事务总结"
date:   2018-01-26 20:12:43 +0800
categories: JAVA
---

### 事务定义
我们将事务 定义为对应用程序状态的相关操作的集合
事务具有

1. 原子性(Atomicity)
2. 一致性(Consistency)
3. 隔离性(Oslation)
4. 持久性(Durability)

这些属性统称为 ACID 属性

#### 原子性
一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性

#### 一致性
数据库总是从一个一致性的状态转换到另一个一致性的状态

#### 隔离性
一个事务所做的修改在最终提交以前，对其他事务是不可见的

#### 持久性
一旦事务提交，则其所做的修改会永久保存到数据库

总结：原子性是基础，隔离性是手段，一致性是目的，持久性是结果

### 数据库隔离级别
1. 读未提交(uncommitted) 会出现 脏读，不可重复读，幻读
2. 读已提交(committed) 不会出现脏读，但会出现 不可重复读，幻读
3. 可重复读(repeatable read) 不会出现 脏读，不可重复读， 会出现幻读
4. 可串行化(Serializable) 脏读，不可重复读，幻读都不会出现

PS: 读已提交 committed 是大多数数据库默认采用的一种隔离级别

脏读和幻读
脏读 在uncommitted 隔离级别下会出现 这种隔离级别下 不同的事务之间可以读到其他事务未提交的数据，即不是终态的数据，脏数据
幻读 读到原先没有或原先有现在没有的数据 在数据表新增或删除时容易出现

不可重复读：两次读到的数据不同

脏读一般通过锁行可以解决，幻读需要锁表

### Spring事务传播属性
> Spring事务传播是Spring在解耦业务操作时需要解决的一个数据库操作问题，可简单理解成将原先使用JDBC在一个事务中的所有操作拆解成不同的Service时，出现的事务管理问题的Spring解决方案

Spring事务传播，即事务从哪里来，将要传播到哪里去？
我们以A和B两个方法为例，在Spring中从方法A到方法B，需要面临以下几种传播情况：
1. A有事务，B有事务
2. A有事务，B无事务
3. A无事务，B有事务
4. A无事务，B无事务

Spring对于以上4中传播情形，分别给出了不同使用场景下传播属性的设置办法

假设事务从方法 A 传播到方法 B，您需要面对方法 B，问自己一个问题：方法 A 有事务吗？

1. 如果没有，就新建一个事务；如果有，就加入当前事务。这就是`PROPAGATION_REQUIRED`，它也是 Spring 提供的默认事务传播行为，适合绝大多数情况
2. 如果没有，就新建一个事务；如果有，就将当前事务挂起。这就是`PROPAGATION_REQUIRES_NEW`，意思就是创建了一个新事务，它和原来的事务没有任何系了
3. 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。这就是`PROPAGATION_NESTED`也就是传说中的“嵌套事务”了，所嵌套的子事务与主事务之间是有关联的（当主事务提交或回滚，子事务也会提交或回滚）
4. 如果没有，就以非事务方式执行；如果有，就使用当前事务。这就是`PROPAGATION_SUPPORTS`这种方式非常随意，没有就没有，有就有，有点无所谓的态度，反正我是支持你的
5. 如果没有，就以非事务方式执行；如果有，就将当前事务挂起,这就是`PROPAGATION_NOT_SUPPORTED`，这种方式非常强硬，没有就没有，有我也不支持你，把你挂起来，不鸟你
6. 如果没有，就以非事务方式执行；如果有，就抛出异常,这就是`PROPAGATION_NEVER`，这种方式更猛，没有就没有，有了反而报错，确实够牛的，它说：我从不支持事务
7. 如果没有，就抛出异常；如果有，就使用当前事务,这就是`PROPAGATION_MANDATORY`，这种方式可以说是牛逼中的牛逼了，没有事务直接就报错，确实够狠的，它说：我必须要有事务



